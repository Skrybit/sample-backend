import { Pool, PoolClient, QueryResult } from 'pg';
import { Inscription } from '../types';

import { PG_POOL_CONFIG } from '../config/network';

const pool = new Pool(PG_POOL_CONFIG);

export async function initDatabase() {
  let client: PoolClient | null = null;
  try {
    client = await pool.connect();

    await client.query(`
      CREATE TABLE IF NOT EXISTS inscriptions (
        id bigint generated by default as identity not null,
        temp_private_key text null,
        address text null,
        required_amount bigint null,
        file_size bigint null,
        recipient_address text null,
        sender_address text null,
        fee_rate real null,
        commit_tx_id text null,
        reveal_tx_hex text null,
        status text not null default 'pending'::text,
        reveal_tx_id text null,
        created_block bigint not null default '0'::bigint,
        last_checked_block bigint not null default '0'::bigint,
        created_at timestamp without time zone not null default now(),
        constraint inscriptions_pkey primary key (id)
      )
    `);

    console.log('PostgreSQL database initialized successfully');
  } catch (error) {
    console.error('Error initializing database:', error);
    throw error;
  } finally {
    if (client) client.release();
  }
}

async function query(text: string, params?: any[]): Promise<QueryResult> {
  const client = await pool.connect();
  try {
    return await client.query(text, params);
  } finally {
    client.release();
  }
}

export async function getInscription(id: number): Promise<Inscription | null> {
  const result = await query('SELECT * FROM inscriptions WHERE id = $1', [id]);
  return result.rows[0] || null;
}

export async function getInscriptionBySender(senderAddress: string): Promise<Inscription[]> {
  const result = await query('SELECT * FROM inscriptions WHERE sender_address = $1', [senderAddress]);
  return result.rows as Inscription[];
}

export async function deletePendingInscriptionBySender(senderAddress: string, status = 'pending'): Promise<number> {
  const result = await query('DELETE FROM inscriptions WHERE sender_address = $1 and status = $2', [
    senderAddress,
    status,
  ]);
  console.log('delete result', result);
  return result.rowCount || 0;
}

export async function updateInscription({
  id,
  commitTxId,
  revealTxHex,
  status,
  lastCheckedBlock,
  revealTxId,
}: {
  id: number;
  commitTxId?: string;
  revealTxHex?: string;
  status?: string;
  lastCheckedBlock?: number;
  revealTxId?: string;
}): Promise<number> {
  const fields = [];
  const values = [];
  let paramIndex = 1;

  if (commitTxId) {
    fields.push(`commit_tx_id = $${paramIndex++}`);
    values.push(commitTxId);
  }

  if (revealTxHex) {
    fields.push(`reveal_tx_hex = $${paramIndex++}`);
    values.push(revealTxHex);
  }

  if (status) {
    fields.push(`status = $${paramIndex++}`);
    values.push(status);
  }

  if (lastCheckedBlock) {
    fields.push(`last_checked_block = $${paramIndex++}`);
    values.push(lastCheckedBlock);
  }

  if (revealTxId) {
    fields.push(`reveal_tx_id = $${paramIndex++}`);
    values.push(revealTxId);
  }

  values.push(id);

  const queryText = `
      UPDATE inscriptions 
      SET ${fields.join(', ')}
      WHERE id = $${paramIndex}
      RETURNING id
    `;

  const result = await query(queryText, values);
  return result.rows[0].id;
}

export async function updateInscriptionStatus({ id, status }: { id: number; status: string }): Promise<number> {
  return updateInscription({ id, status });
}

export async function updateInscriptionLastCheckedBlock({
  id,
  lastCheckedBlock,
}: {
  id: number;
  lastCheckedBlock: number;
}): Promise<number> {
  return updateInscription({ id, lastCheckedBlock });
}

export async function updateInscriptionRevealTxId({
  id,
  revealTxId,
}: {
  id: number;
  revealTxId: string;
}): Promise<number> {
  return updateInscription({ id, revealTxId });
}

// export async function createFullInscriptionRecord({
export async function insertInscription({
  tempPrivateKey,
  address,
  requiredAmount,
  fileSize,
  recipientAddress,
  senderAddress,
  feeRate,
  createdBlock,
}: {
  tempPrivateKey: string;
  address: string;
  requiredAmount: string;
  fileSize: number;
  recipientAddress: string;
  senderAddress: string;
  feeRate: string;
  createdBlock: number;
}): Promise<Inscription> {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');

    // Insert wallets
    // await client.query(
    //   `INSERT INTO wallets (address, private_key)
    //    VALUES ($1, $2)
    //    ON CONFLICT (address) DO NOTHING`,
    //   [paymentAddress, privateKey]
    // );

    // await client.query(
    //   `INSERT INTO wallets (address)
    //    VALUES ($1)
    //    ON CONFLICT (address) DO NOTHING`,
    //   [senderAddress]
    // );

    // await client.query(
    //   `INSERT INTO wallets (address)
    //    VALUES ($1)
    //    ON CONFLICT (address) DO NOTHING`,
    //   [recipientAddress]
    // );

    // Get wallet IDs
    // const paymentWallet = await client.query(
    //   `SELECT id FROM wallets WHERE address = $1`,
    //   [paymentAddress]
    // );
    // const senderWallet = await client.query(
    //   `SELECT id FROM wallets WHERE address = $1`,
    //   [senderAddress]
    // );
    // const recipientWallet = await client.query(
    //   `SELECT id FROM wallets WHERE address = $1`,
    //   [recipientAddress]
    // );

    // Create inscription
    const inscriptionResult = await client.query(
      `INSERT INTO inscriptions (
        temp_private_key, address, required_amount,
        file_size, recipient_address, sender_address, 
        fee_rate, created_block, last_checked_block
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
      RETURNING *`,
      [
        tempPrivateKey,
        address,
        requiredAmount,
        fileSize,
        recipientAddress,
        senderAddress,
        feeRate,
        createdBlock,
        createdBlock,
      ],
    );

    const inscription = inscriptionResult.rows[0];

    // Record initial status
    // await client.query(
    //   `INSERT INTO status_updates (inscription_id, new_status)
    //    VALUES ($1, $2)`,
    //   [inscriptionId, initialStatus],
    // );

    // Record initial block check
    // await client.query(
    //   `INSERT INTO block_checks (inscription_id, block_number)
    //    VALUES ($1, $2)`,
    //   [inscriptionId, createdBlock],
    // );

    await client.query('COMMIT');
    return inscription;
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}

process.on('SIGINT', async () => {
  await pool.end();
  console.log('PostgreSQL pool closed');
  // do we need it?
  process.exit(0);
});
